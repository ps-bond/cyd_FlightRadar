esphome:
  name: cyd-flightradar
  friendly_name: cyd-flightradar

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "iLaOFkw5jiCOGOn+AqeoEyh2AsgE3wzDxquwgThIUvk="

ota:
  - platform: esphome
    password: "e7011bf2781486a3ea1edca40604a93c"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# This section is for the display itself (ILI9341 driver)
spi:
  - id: tft
    clk_pin: GPIO14
    mosi_pin: GPIO13
    miso_pin: GPIO12

# Display backlight control
output:
  - platform: ledc
    pin: GPIO21
    id: display_backlight_output

light:
  - platform: monochromatic
    output: display_backlight_output
    name: "Display Backlight"
    restore_mode: ALWAYS_ON

# Custom font
font:
    file: "gfonts://Arimo"
    id: my_font
    size: 20
    glyphs:
      # Include all printable ASCII characters and the degree symbol
      - " 0123456789!\"#$%&'()*+,-./:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Â°"

json:

# This section is for the display's pins
display:
  - platform: ili9xxx
    id: cyd_display
    spi_id: tft
    model: ILI9341
    cs_pin: GPIO15
    dc_pin: GPIO2
    reset_pin: GPIO4

    update_interval: 15s
    auto_clear_enabled: true
    transform:
      swap_xy: true
      mirror_x: false
    dimensions:
      width: 320
      height: 240

    color_palette: 8BIT
    invert_colors: false

    # The Cheap Yellow Display uses a separate SPI bus for the touchscreen
    # You might need to adjust these pins if your board is a different variant
    # See the pinout diagram for your specific board.
    # We will not be using the touch screen for this project but the config is often included.
    # touch_cs_pin: GPIO33 
    # touch_type: "xpt2046" 
    
    # Default VSPI pins
    # tf_miso_pin: GPIO19
    # tf_mosi_pin: GPIO23
    # tf_sck_pin: GPIO18
    # tf_cs_pin: GPIO5

    # ldr_pin: GPIO34

    # cn1_i2c_sda_pin: GPIO22
    # cn1_i2c_scl_pin: GPIO27
    # or vice-versa

    lambda: |-
      // Clear the screen for a fresh draw
      it.clear();
      
      // Print the title. This will show the count as soon as it's available.
      if (id(flight_count_sensor).has_state())
      {
        it.printf(0, 0, id(my_font), "Flights: %.0f", id(flight_count_sensor).state);
      }
      else
      {
        it.print(0, 0, id(my_font), "Waiting for data...");
      }

      if (id(flight_data_sensor).has_state())
      {
        std::string x = id(flight_data_sensor).raw_state;

        // The 'x' variable is a Python-style string. We must convert it to valid JSON.
        std::string json_string;
        json_string.reserve(x.length());

        // This loop converts the Python string representation to a valid JSON string.
        // It handles single quotes, double quotes inside strings, and the 'None' keyword.
        for (size_t i = 0; i < x.length(); ++i)
        {
          char c = x[i];
          if (c == '\'')
          {
            json_string += '"';
          }
          else if (c == '"')
          {
            // Escape existing double quotes
            json_string += "\\\"";
          }
          else if (c == 'N' && x.substr(i, 4) == "None")
          {
            json_string += "null";
            i += 3; // Advance loop past 'one'
          }
          else
          {
            json_string += c;
          }
        }

        StaticJsonDocument<8192> doc;
        DeserializationError error = deserializeJson(doc, json_string);
        if (error)
        {
          ESP_LOGE("json", "deserializeJson() failed: %s", error.c_str());
          it.print(0, 30, id(my_font), "JSON Error");
          return;
        }

        JsonArray flights = doc.as<JsonArray>();
        if (flights.size() > 0)
        {
          int y_offset = 30;
          for (JsonVariant flight : flights)
          {
            // Extract registration, defaulting to "BLOCKED" if null or empty
            const char* registration = flight["aircraft_registration"].as<const char*>();
            std::string reg_str = (registration == nullptr || strlen(registration) == 0) ? "BLOCKED" : registration;

            // Extract aircraft model name, defaulting to "N/A" if null
            const char* model = flight["aircraft_model"].as<const char*>();
            std::string model_str = (model == nullptr) ? "N/A" : model;

            // Determine flight type (Commercial vs. Private)
            const char* type_ptr = flight["airline_short"].as<const char*>();
            if (type_ptr == nullptr || strlen(type_ptr) == 0) { type_ptr = "Private"; }

            // Print the formatted flight information
            // Line 1: Registration and Model
            it.printf(0, y_offset, id(my_font), "%s (%s)", reg_str.c_str(), model_str.c_str());
            y_offset += 20;

            // Line 2: Flight Type
            it.printf(15, y_offset, id(my_font), "%s", type_ptr);
            y_offset += 20;

            // Line 3: Origin and Destination, if available
            const char* origin = flight["airport_origin_code_iata"].as<const char*>();
            const char* dest = flight["airport_destination_code_iata"].as<const char*>();
            if (origin != nullptr && dest != nullptr)
            {
              it.printf(15, y_offset, id(my_font), "%s > %s", origin, dest);
              y_offset += 20;
            }

            // Line 4: Movement Status (Landed or Speed/Heading)
            if (flight["on_ground"] == 1)
            {
              it.printf(15, y_offset, id(my_font), "(On ground)");
            }
            else
            {
              int speed = flight["ground_speed"];
              int heading = flight["heading"];
              it.printf(15, y_offset, id(my_font), "%d kts @ %d%c", speed, heading, 176); // 176 is the degree symbol
            }
            y_offset += 25; // Add extra space before the next flight
          }
        }
      }
      else
      {
        it.print(0, 30, id(my_font), "No flights in area.");
      }

sensor:
  - platform: homeassistant
    id: flight_count_sensor
    entity_id: sensor.flightradar24_current_in_area
    accuracy_decimals: 0
    internal: true

# A Home Assistant text sensor to get the flight data
text_sensor:
  - platform: homeassistant
    id: flight_data_sensor
    entity_id: sensor.flightradar24_current_in_area
    attribute: flights
    on_raw_value:
      then:
        - lambda: |-
            ESP_LOGD("flight_data", "Received new flight data from Home Assistant.");
