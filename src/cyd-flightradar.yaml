esphome:
  name: cyd-flightradar
  friendly_name: cyd-flightradar

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "iLaOFkw5jiCOGOn+AqeoEyh2AsgE3wzDxquwgThIUvk="

ota:
  - platform: esphome
    password: "e7011bf2781486a3ea1edca40604a93c"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# This section is for the display itself (ILI9341 driver)
spi:
  - id: tft
    clk_pin: GPIO14
    mosi_pin: GPIO13
    miso_pin: GPIO12

# Display backlight control
output:
  - platform: ledc
    pin: GPIO21
    id: display_backlight_output

light:
  - platform: monochromatic
    id: display_backlight
    output: display_backlight_output
    name: "Display Backlight"
    restore_mode: ALWAYS_ON

# Custom font
font:
    file: "gfonts://Arimo"
    id: display_font
    size: 16
    glyphs:
      # Include all printable ASCII characters and the degree symbol
      - " 0123456789!\"#$%&'()*+,-./:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~°"

# Needed to force ESPHome to link in ArduinoJson library
json:

# This section is for the display's pins
display:
  - platform: ili9xxx
    id: cyd_display
    spi_id: tft
    model: ILI9341
    cs_pin: GPIO15
    dc_pin: GPIO2
    reset_pin: GPIO4

    update_interval: 15s
    auto_clear_enabled: true
    transform:
      swap_xy: true
      mirror_x: false
    dimensions:
      width: 320
      height: 240

    color_palette: 8BIT
    invert_colors: false

    # The Cheap Yellow Display uses a separate SPI bus for the touchscreen
    # You might need to adjust these pins if your board is a different variant
    # See the pinout diagram for your specific board.
    # We will not be using the touch screen for this project but the config is often included.
    # touch_cs_pin: GPIO33 
    # touch_type: "xpt2046" 
    
    # Default VSPI pins
    # tf_miso_pin: GPIO19
    # tf_mosi_pin: GPIO23
    # tf_sck_pin: GPIO18
    # tf_cs_pin: GPIO5

    # ldr_pin: GPIO34

    # cn1_i2c_sda_pin: GPIO22
    # cn1_i2c_scl_pin: GPIO27
    # or vice-versa

    lambda: |-
      // Clear the screen for a fresh draw
      it.clear();
      
      // Print the title. This will show the count as soon as it's available.
      if (id(flight_count_sensor).has_state())
      {
        it.printf(0, 0, id(display_font), "Flights: %.0f", id(flight_count_sensor).state);
      }
      else
      {
        it.print(0, 0, id(display_font), "Waiting for data...");
      }

      if (id(flight_data_sensor).has_state())
      {
        std::string json_string = id(flight_data_sensor).raw_state;

        // The raw state is a Python-style string. We must convert it to valid JSON.
        // This is CPU-intensive and a primary risk for watchdog timeouts.
        // Offloading this to a Home Assistant template sensor is the recommended fix.
        // This is a slightly more efficient way to do it on-device, but the risk remains.
        size_t pos = 0;
        while ((pos = json_string.find('\'', pos)) != std::string::npos) 
        {
            json_string.replace(pos, 1, "\"");
            pos++;
        }
        pos = 0;
        while ((pos = json_string.find("None", pos)) != std::string::npos) 
        {
            json_string.replace(pos, 4, "null");
            pos++;
        }

        // By declaring the JsonDocument as static, we allocate its 8KB memory pool
        // only once when the program starts, instead of on the stack every time
        // this lambda runs. This is a major stack memory optimization.
        static StaticJsonDocument<8192> doc;
        DeserializationError error = deserializeJson(doc, json_string);
        if (error)
        {
          ESP_LOGE("json", "deserializeJson() failed: %s", error.c_str());
          it.print(0, 30, id(display_font), "JSON Error");
          return;
        }

        JsonArray flights = doc.as<JsonArray>();
        if (flights.size() > 0)
        {
          // Get screen height and set a safe estimate for the height of one flight block.
          const int screen_height = it.get_height();
          const int flight_block_height = 68; // Max height: 17+17+17(optional)+17(padding)
          int y_offset = 30;

          // Define a tolerance for vertical speed to consider flight as "level".
          static const int vs_level_tolerance = 10;

          for (JsonVariant flight : flights)
          {
            // Before drawing, check if the next flight block will fit on the screen.
            if (y_offset + flight_block_height > screen_height) 
            {
              break;
            }

            // Use the | operator to provide a default value if the JSON key is missing or null.
            std::string reg_str = flight["aircraft_registration"] | "BLOCKED";
            std::string model_str = flight["aircraft_model"] | "N/A";

            // Check if airline_short is null.
            // If it is, use airline with a fallback to "Private". Otherwise, use airline_short.
            std::string type_str;
            if (flight["airline_short"].isNull()) 
            {
              type_str = flight["airline"] | "Private";
            }
            else 
            {
              type_str = flight["airline_short"].as<const char*>();
            }

            // Print the formatted flight information
            // Line 1: Registration and Model
            it.printf(0, y_offset, id(display_font), "%s (%s)", reg_str.c_str(), model_str.c_str());
            y_offset += 17;

            // Line 2: Flight Type
            it.printf(15, y_offset, id(display_font), "%s", type_str.c_str());
            y_offset += 17;

            // Line 3: Origin and Destination, if available
            std::string origin = flight["airport_origin_code_iata"] | "";
            std::string dest = flight["airport_destination_code_iata"] | "";
            if (!origin.empty() && !dest.empty())
            {
              it.printf(15, y_offset, id(display_font), "%s > %s", origin.c_str(), dest.c_str());
              y_offset += 17;
            }

            // Line 4: Movement Status. Use a default of -1.0 to indicate if distance is unavailable.
            float distance = flight["distance"] | -1.0;
            if (flight["on_ground"] == 1)
            {
              // Only print distance if it's valid (not our -1.0 sentinel value)
              if (distance >= 0.0)
              {
                it.printf(15, y_offset, id(display_font), "%.1fkm (On ground)", distance);
              }
              else
              {
                it.printf(15, y_offset, id(display_font), "(On ground)");
              }
            }
            else
            {
              int speed = flight["ground_speed"] | 0;
              int heading = flight["heading"] | 0;
              int altitude = flight["altitude"] | 0;
              int vs = flight["vertical_speed"] | 0;

              // Determine vertical speed status string
              // A tolerance (e.g., +/- 10) prevents flickering between states for minor fluctuations.
              std::string vs_status;
              if (vs > vs_level_tolerance)
              {
                vs_status = "CLM";
              }
              else if (vs < -vs_level_tolerance)
              {
                vs_status = "DSC";
              }
              else
              {
                vs_status = "LVL";
              }

              // Only print distance if it's valid
              if (distance >= 0.0)
              {
                it.printf(15, y_offset, id(display_font), "%.1fkm %d kts @ %d° %dft %s", distance, speed, heading, altitude, vs_status.c_str());
              }
              else
              {
                it.printf(15, y_offset, id(display_font), "%d kts @ %d° %dft %s", speed, heading, altitude, vs_status.c_str());
              }
            }
            y_offset += 21; // Add extra space before the next flight
          }
        }
      }
      else
      {
        it.print(0, 30, id(display_font), "No flights in area.");
      }

sensor:
  - platform: homeassistant
    id: flight_count_sensor
    entity_id: sensor.flightradar24_current_in_area
    accuracy_decimals: 0
    internal: true
  
  - platform: adc
    id: ambient_light_sensor
    pin: GPIO34
    name: "Ambient Light Level"
    update_interval: 10s
    attenuation: auto
    filters:
      # The LDR on the CYD board typically gives a lower voltage in bright light
      # and a higher voltage in darkness. We will map the desired range to a
      # brightness level between 30% and 100%.
       - calibrate_linear:
          - 0.05 -> 0.85  # Brightest condition -> 100% brightness
          - 0.63 -> 0.2 # Dim condition -> 30% brightness
      # Clamp the output between 30% and 100% to ensure it's always in a valid range.
       - clamp:
          min_value: 0.2
          max_value: 0.85
    on_value:
      then:
        # Use the calibrated sensor value to set the display backlight brightness.
        - light.turn_on:
            id: display_backlight
            brightness: !lambda 'return x;'
            transition_length: 2s

# A Home Assistant text sensor to get the flight data
text_sensor:
  - platform: homeassistant
    id: flight_data_sensor
    entity_id: sensor.flightradar24_current_in_area
    attribute: flights
    on_raw_value:
      then:
        - lambda: |-
            ESP_LOGD("flight_data", "Received new flight data from Home Assistant.");
