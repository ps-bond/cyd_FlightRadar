esphome:
  name: cyd-flightradar
  friendly_name: cyd-flightradar

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "iLaOFkw5jiCOGOn+AqeoEyh2AsgE3wzDxquwgThIUvk="

ota:
  - platform: esphome
    password: "e7011bf2781486a3ea1edca40604a93c"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# This section is for the display itself (ILI9341 driver)
spi:
  - id: tft
    clk_pin: GPIO14
    mosi_pin: GPIO13
    miso_pin: GPIO12

# Display backlight control
output:
  - platform: ledc
    pin: GPIO21
    id: display_backlight_output

light:
  - platform: monochromatic
    output: display_backlight_output
    name: "Display Backlight"
    restore_mode: ALWAYS_ON

# Custom font
font:
    file: "gfonts://Arimo"
    id: display_font
    size: 20
    glyphs:
      # Include all printable ASCII characters and the degree symbol
      - " 0123456789!\"#$%&'()*+,-./:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"

json:

# This section is for the display's pins
display:
  - platform: ili9xxx
    id: cyd_display
    spi_id: tft
    model: ILI9341
    cs_pin: GPIO15
    dc_pin: GPIO2
    reset_pin: GPIO4

    update_interval: 15s
    auto_clear_enabled: true
    transform:
      swap_xy: true
      mirror_x: false
    dimensions:
      width: 320
      height: 240

    color_palette: 8BIT
    invert_colors: false

    # The Cheap Yellow Display uses a separate SPI bus for the touchscreen
    # You might need to adjust these pins if your board is a different variant
    # See the pinout diagram for your specific board.
    # We will not be using the touch screen for this project but the config is often included.
    # touch_cs_pin: GPIO33 
    # touch_type: "xpt2046" 
    
    # Default VSPI pins
    # tf_miso_pin: GPIO19
    # tf_mosi_pin: GPIO23
    # tf_sck_pin: GPIO18
    # tf_cs_pin: GPIO5

    # ldr_pin: GPIO34

    # cn1_i2c_sda_pin: GPIO22
    # cn1_i2c_scl_pin: GPIO27
    # or vice-versa

    lambda: |-
      // Clear the screen for a fresh draw
      it.clear();
      
      // Print the title. This will show the count as soon as it's available.
      if (id(flight_count_sensor).has_state())
      {
        it.printf(0, 0, id(display_font), "Flights: %.0f", id(flight_count_sensor).state);
      }
      else
      {
        it.print(0, 0, id(display_font), "Waiting for data...");
      }

      if (id(flight_data_sensor).has_state())
      {
        std::string x = id(flight_data_sensor).raw_state;

        // The 'x' variable is a Python-style string. We must convert it to valid JSON.
        std::string json_string;
        json_string.reserve(x.length());

        // This loop converts the Python string representation to a valid JSON string.
        // It handles single quotes, double quotes inside strings, and the 'None' keyword.
        for (size_t i = 0; i < x.length(); ++i)
        {
          char c = x[i];
          if (c == '\'')
          {
            json_string += '"';
          }
          else if (c == '"')
          {
            // Escape existing double quotes
            json_string += "\\\"";
          }
          else if (c == 'N' && x.substr(i, 4) == "None")
          {
            json_string += "null";
            i += 3; // Advance loop past 'one'
          }
          else
          {
            json_string += c;
          }
        }

        // By declaring the JsonDocument as static, we allocate its 8KB memory pool
        // only once when the program starts, instead of on the stack every time
        // this lambda runs. This is a major stack memory optimization.
        static StaticJsonDocument<8192> doc;
        DeserializationError error = deserializeJson(doc, json_string);
        if (error)
        {
          ESP_LOGE("json", "deserializeJson() failed: %s", error.c_str());
          it.print(0, 30, id(display_font), "JSON Error");
          return;
        }

        JsonArray flights = doc.as<JsonArray>();
        if (flights.size() > 0)
        {
          // Get screen height and set a safe estimate for the height of one flight block.
          const int screen_height = it.get_height();
          const int flight_block_height = 90; // Max height: 20+20+20(optional)+25(padding)
          int y_offset = 30;

          for (JsonVariant flight : flights)
          {
            // Before drawing, check if the next flight block will fit on the screen.
            if (y_offset + flight_block_height > screen_height) { break; }

            // Use the | operator to provide a default value if the JSON key is missing or null.
            std::string reg_str = flight["aircraft_registration"] | "BLOCKED";
            std::string model_str = flight["aircraft_model"] | "N/A";
            std::string type_str = flight["airline_short"] | "Private";

            // Print the formatted flight information
            // Line 1: Registration and Model
            it.printf(0, y_offset, id(display_font), "%s (%s)", reg_str.c_str(), model_str.c_str());
            y_offset += 20;

            // Line 2: Flight Type
            it.printf(15, y_offset, id(display_font), "%s", type_str.c_str());
            y_offset += 20;

            // Line 3: Origin and Destination, if available
            std::string origin = flight["airport_origin_code_iata"].as<std::string>();
            std::string dest = flight["airport_destination_code_iata"].as<std::string>();
            if (!origin.empty() && !dest.empty())
            {
              it.printf(15, y_offset, id(display_font), "%s > %s", origin.c_str(), dest.c_str());
              y_offset += 20;
            }

            // Line 4: Movement Status. Use a default of -1.0 to indicate if distance is unavailable.
            float distance = flight["distance"] | -1.0;
            if (flight["on_ground"] == 1)
            {
              // Only print distance if it's valid (not our -1.0 sentinel value)
              if (distance >= 0.0)
              {
                it.printf(15, y_offset, id(display_font), "%.1fkm (On ground)", distance);
              }
              else
              {
                it.printf(15, y_offset, id(display_font), "(On ground)");
              }
            }
            else
            {
              int speed = flight["ground_speed"] | 0;
              int heading = flight["heading"] | 0;
              // Only print distance if it's valid
              if (distance >= 0.0)
              {
                it.printf(15, y_offset, id(display_font), "%.1fkm %d kts @ %d°", distance, speed, heading);
              }
              else
              {
                it.printf(15, y_offset, id(display_font), "%d kts @ %d°", speed, heading);
              }
            }
            y_offset += 25; // Add extra space before the next flight
          }
        }
      }
      else
      {
        it.print(0, 30, id(display_font), "No flights in area.");
      }

sensor:
  - platform: homeassistant
    id: flight_count_sensor
    entity_id: sensor.flightradar24_current_in_area
    accuracy_decimals: 0
    internal: true

# A Home Assistant text sensor to get the flight data
text_sensor:
  - platform: homeassistant
    id: flight_data_sensor
    entity_id: sensor.flightradar24_current_in_area
    attribute: flights
    on_raw_value:
      then:
        - lambda: |-
            ESP_LOGD("flight_data", "Received new flight data from Home Assistant.");
